#N canvas 449 37 561 562 10;
#X obj 4 328 cnv 3 550 3 empty empty inlets 8 12 0 13 #dcdcdc #000000 0;
#X obj 4 419 cnv 3 550 3 empty empty outlets 8 12 0 13 #dcdcdc #000000 0;
#X obj 4 471 cnv 3 550 3 empty empty flags 8 12 0 13 #dcdcdc #000000 0;
#X obj 136 426 cnv 17 3 17 empty empty 0 5 9 0 16 #dcdcdc #9c9c9c 0;
#X obj 4 539 cnv 15 552 21 empty empty empty 20 12 0 14 #e0e0e0 #202020 0;
#X obj 136 335 cnv 17 3 79 empty empty 0 5 9 0 16 #dcdcdc #9c9c9c 0;
#X obj 4 2 cnv 15 301 42 empty empty keypress 20 20 2 37 #e0e0e0 #000000 0;
#X obj 307 3 cnv 15 250 40 empty empty empty 12 13 0 18 #7c7c7c #e0e4dc 0;
#N canvas 0 22 450 278 (subpatch) 0;
#X coords 0 1 100 -1 302 42 1;
#X restore 3 2 graph;
#X obj 346 10 cnv 10 10 10 empty empty ELSE 0 15 2 30 #7c7c7c #e0e4dc 0;
#X obj 22 39 cnv 4 4 4 empty empty Key\ learn 0 28 2 18 #e0e0e0 #000000 0;
#X obj 459 10 cnv 10 10 10 empty empty EL 0 6 2 13 #7c7c7c #e0e4dc 0;
#X obj 479 10 cnv 10 10 10 empty empty Locus 0 6 2 13 #7c7c7c #e0e4dc 0;
#X obj 516 10 cnv 10 10 10 empty empty Solus' 0 6 2 13 #7c7c7c #e0e4dc 0;
#X obj 465 25 cnv 10 10 10 empty empty ELSE 0 6 2 13 #7c7c7c #e0e4dc 0;
#X obj 503 25 cnv 10 10 10 empty empty library 0 6 2 13 #7c7c7c #e0e4dc 0;
#N canvas 0 22 450 278 (subpatch) 0;
#X coords 0 1 100 -1 252 42 1 0 0;
#X restore 306 2 graph;
#X text 209 367 query;
#X msg 223 218 query;
#X obj 262 288 else/display;
#X text 245 382 - forget input, f 42;
#X obj 136 448 cnv 17 3 17 empty empty 1 5 9 0 16 #dcdcdc #9c9c9c 0;
#X text 203 382 forget;
#X text 245 367 - print send stored input on right outlet, f 42;
#X text 215 336 bang -;
#X obj 187 288 else/display;
#X text 155 398 teach <symbol>;
#X text 245 398 - teach a specific key, f 42;
#X text 257 336 activate key learn, f 40;
#X text 170 426 bang/float -;
#X text 194 449 symbol -;
#X text 248 449 learned key, f 41;
#X text 248 427 from learned key depending on the mode, f 41;
#X text 155 351 toggle <float>;
#X text 245 351 - non zero sets to toggle mode, f 42;
#N canvas 674 194 360 265 toggle 0;
#X obj 210 194 else/display;
#X obj 123 197 else/display;
#X text 44 32 In toggle mode you have "1" for when the learned key is pressed and 0 when it is released., f 40;
#X msg 123 124 toggle \$1;
#X obj 123 101 tgl 16 0 empty empty empty 0 -8 0 10 #fcfcfc #000000 #000000 0 1;
#X obj 123 162 else/keypress a;
#X connect 3 0 5 0;
#X connect 4 0 3 0;
#X connect 5 0 1 0;
#X connect 5 1 0 0;
#X restore 450 284 pd toggle;
#X msg 187 157 set Space;
#X msg 213 191 learn;
#X msg 144 157 set a;
#X obj 46 266 key;
#X text 250 156 set a specific key;
#X text 275 186 Whenever the abstraction learns something new \, you'll be prompted to save your patch when you close it \, so it gets saved. After sending "leanr" \, press a key to teach the object., f 42;
#X obj 4 505 cnv 3 550 3 empty empty arguments 8 12 0 13 #dcdcdc #000000 0;
#X text 155 479 -toggle - sets to toggle output (default bang);
#X text 155 513 1) symbol - sets a key name (default noneg);
#X msg 116 210 set;
#X text 80 209 none;
#X text 52 81 [keypress] uses key presses of a single key to send a bang or a toggle. You can set the key symbol as an argument or ask the object to "learn" a pressed key (useful for kys like "shift" and stuff) \, which is then saved as an argument in the owning patch. Note that autorepeated keys are filtered! Key presses in edit mode are also filtered!, f 73;
#X obj 187 262 else/keypress Alt_L;
#X connect 18 0 48 0;
#X connect 36 0 48 0;
#X connect 37 0 48 0;
#X connect 38 0 48 0;
#X connect 45 0 48 0;
#X connect 48 0 25 0;
#X connect 48 1 19 0;
